This text file is merely a blob of info I threw onto it when following Miguel Grinberg's Flask Tutorial.
The text is **ROUGHLY** in order. Use this as a reference, not as a novel ;)

D: = Dependency
* D: flask-wtf: library used to create web forms.

To use this extension, the flask instance "app" object must be configured with a secret key.
*IMPORTANT: Protects against Cross-Site Request Forgery. CSRF
implemented in the template as a hidden input inside a form: {{ form.hidden_tag() }}

* flash() method
To use this, you must both call the method when the route is called and call "get_flashed_messages()"
in the template. The way I think of this is that it is placed into a buffer which is loaded
onto the next screen.

* validation errors -
Flask-wtf validators that are passed to StringField, PasswordField etc constructors contain an
iterable error list object. Simply call them in the template: form.username.errors, or form.password.errors

* url_for -
url_for allows for generating URLs for specific views and enables less fragile code.
If the code is restructured within the filesystem, url_for() will retrieve the URL dynamically.
Just specify the name of the view minus the "html" extension.
so for "dir/dir/dir/index.html" - instead say url_for('index')
urls are no longer hardcoded into views

DATABASES: -------------------------------------------------

Workflow:
            1) install dependencies: flask-sqlalchemy, flask-migrate
            2) setup database configuration URL in Config class; turn tracking on/off
            3) instantiate SQLAlchemy object in __init__.py, passing app to the instance
            4) instantiate Migrate object in __init__.py, passing db and app to instance
            5) create models:
                create table schema, optimize performance (create an index), define relationships.
                __repr__(self): define this for debugging
                NOTE: after this step is completed, the model only exists as Python objects.
                      These models need to be migrated (generated into a script),
                      then applied to an actual database.
            6) Initialize migration framework: flask db init
            6) create migration scripts - flask db migrate -m "description"
            7) apply/remove migrations to the database - (apply)flask db upgrade OR (remove) flask db downgrade
            

Models:
            *All classes inside of models.py inherit from the SQLAlchemy class called "Model"
                ex, [SQLAlchemy instance].Model or "class MyModel(db.Model)"

* D: flask-sqlalchemy: (Object Relational Mapper)
    - supports SQLite, MySQL, and Postgres.
    - enables an application to switch from any one of these DBMS systems without
        making changes to the application
    - I am using SQLite as a development-only database for this tutorial.
        may also be a good production tool for gvlswing.com admin CMS since it will be small
        scale and simple for now.

* D: flask-migrate: (Database Migration Framework) Alembic migration framework flask extension
    - The migration framework is for development purposes. Because development often requires making
        changes to the database schema, this framework helps to place those changes, which are tedious
        when performed by hand in SQL

DB indexing - how to decide what to index?
Ask "what attributes will be searched for or written to most frequently?" !!!
This will optimize searching in the database. This would be interesting to test this with/without index.


When using "os.environ.get() or something", this should make the code less fragile and makes
it more flexible for deployment. All that needs to be done is to set an environment variable in production.

    DB MIGRATIONS:----------------------------------------------------
        initialize migration framework: flask db init
            -creates a migrations directory, among other details

        perform a migration: flask db migrate -m "description"
            -generates the python code/script in a file under migrations/
            comment: some of this code seems familiar and similar to Entity Framework,
            upgrade, downgrade, etc.

        apply migration to db: flask db upgrade
            -this will apply the migration to the actual database.
            this should generate the db file in SQLite.

        undo previous migration: flask db downgrade
            -attempts to undo a previous migration.

        db history: flask db history
            -similar to git hist or log

        current db migration: flask db current
            -similar to git status
            -works only if you have applied a migration already



    CRUD operations -------------------------------------------

    CREATE  db.sesssion.add(element)
    READ    [ModelName].query.get(id) or [ModelName].query.all() or [ModelName].query.order_by()
    UPDATE
    DELETE  db.session.delete(element)

    TRANSACTIONS
    COMMIT changes - db.session.commit()


SESSION / LOGIN----------------------------------------------------------

    * PASSWORD HASHING--------------------------------------------------------
    use werkzeug.security package methods: 1) generate_password_hash("phrase"), 2) check_password_hash(hash, "phrase")
    Every time generate_password_hash() is called, even with the same parameters, a brand-new hash is generated!!!


    DEFINITION: A user "session" is a private storage that is allocated for each client that connects to the application

    D: flask-login (Session Management dependency)
    pipenv install flask-login
    initialization: from flask_login import
                    object: LoginManager -> register tha app with the extension,
                    class: UserMixin -> enables a User model to become compatible with flask-login,
                    static function: login_user -> updates current_user,
                    object: current_user -> represents A) the logged in user or
                                                       B) an anonymous user if they aren't logged in.
    login = LoginManager(app)

    flask-login can work with any User model class. Requires 3 attributes and 1 method to be implemented.
        1) extend your User model from UserMixin -> class User(UserMixin, otherparams)
        2) @login.user_loader function loads the user id into a session. placed in User model as static method.
        3) login_user(user_object)

    ***IMPORTANT*** flask-login treats id's as strings. Must convert to int if you're intending to use it as an int.

    Workflow for Login
                prerequisites - import login_user from flask-login.
                                  - some User model has been created.
                                  - User class must extend/inherit UserMixin.
                                  - import werkzeug.security: generate_password_hash, check_password_hash methods
                                  - implement some set/get password_hash method in your User model

                steps - 1) extend the @login.user_loader function with a function that returns the User's int(id)
                        2) test that the username exists in the database, if so grab the user returned.
                            -use filter_by().first() to check if the username exists
                        3) check hash of the form password against password_hash stored in database.
                        4) redirect user back to login w/ ambiguous flash message if they fail authentication.
                        5) if step 3 suceeds, use login_user(user, remember=true/false) from flask-login to start a new session

    Helpful features:

        set login.login_view to the method that calls the login form page: login.login_view = 'login'
        This will auto-redirect users to the login page when the rule is added *underneath* the @app.route decorators.
        url_for() is used underneath this feature to call the correct action.

        @app.route("/")
        @app.route("/some/route")
        @login_required
        def func():
            pass

        After implementing login_required, it is good practice to redirect the user the page which they originally
        intended to visit in the first place.
        To help with this, flask-login will add URL query string "?next=%2Findex" meaning "next=[originally requested url]"
        After the login is successful, you may redirect the user the to the page they wanted using this query string.
        BUT before you redirect, make sure that the URL is only redirecting to our site and not someone else's, in case of
        attack use werkzeug.urls : url_parse()


REGISTRATION: -------------------------------------------------------

    Heavily relies upon flask-wtf validators. Two methods can be added to the registration form class to instruct
    flask-wtf to validate unique fields within the database as part of validation protocol for that form.

    class RegistrationForm(FlaskForm):
        [form code]

        def validate_[attribute](self, attrib):
            exists = [Model].query.filter_by(attrib=attrib).first()
            if exists is not None:
                raise ValidationError("error validating attrib")

    After this, we do not have to take care of anymore validation in our route. We let flask-wtf do this for us. That
    way we can concentrate on the registration process at a more high level.