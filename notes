This text file is merely a blob of info I threw onto it when following Miguel Grinberg's Flask Tutorial.
The text is **ROUGHLY** in order. Use this as a reference, not as a novel ;)

* Dependencies:
        flask-wtf: library used to create web forms.

To use this extension, the flask instance "app" object must be configured with a secret key.
*SECURITY NOTE: Protects against Cross-Site Request Forgery. CSRF
implemented in the template as a hidden input inside a form: {{ form.hidden_tag() }}

* flash() method
To use this, you must both call the method when the route is called and call "get_flashed_messages()"
in the template. The way I think of this is that it is placed into a buffer which is loaded
onto the next screen.

* validation errors -
Flask-wtf validators that are passed to StringField, PasswordField etc constructors contain an
iterable error list object. Simply call them in the template: form.username.errors, or form.password.errors

* url_for -
url_for allows for generating URLs for specific views and enables less fragile code.
If the code is restructured within the filesystem, url_for() will retrieve the URL dynamically.
Just specify the name of the method that calls the action.

urls are no longer hardcoded into views

DATABASES: -------------------------------------------------

* Dependencies:
    flask-sqlalchemy: (Object Relational Mapper)
        - supports SQLite, MySQL, and Postgres.
        - enables an application to switch from any one of these DBMS systems without
        making changes to the application
        - I am using SQLite as a development-only database for this tutorial.
        may also be a good production tool for gvlswing.com admin CMS since it will be small
        scale and simple for now.

    -flask-migrate: (Database Migration Framework) Alembic migration framework flask extension
        - The migration framework is for development purposes. Because development often requires making
        changes to the database schema, this framework helps to place those changes, which are tedious
        when performed by hand in SQL

Workflow:
            1) install dependencies: flask-sqlalchemy, flask-migrate
            2) setup database configuration URL in Config class; turn tracking on/off
            3) instantiate SQLAlchemy object in __init__.py, passing app to the instance
            4) instantiate Migrate object in __init__.py, passing db and app to instance
            5) create models:
                create table schema, optimize performance (create an index), define relationships.
                __repr__(self): define this for debugging
                NOTE: after this step is completed, the model only exists as Python objects.
                      These models need to be migrated (generated into a script),
                      then applied to an actual database.
            6) Initialize migration framework: flask db init
            7) create migration scripts - flask db migrate -m "description"
            8) apply/remove migrations to the database - (apply)flask db upgrade OR (remove) flask db downgrade
            

Models:
            *All classes inside of models.py inherit from the SQLAlchemy class called "Model"
                ex, [SQLAlchemy instance].Model or "class MyModel(db.Model)"

DB indexing - how to decide what to index?
Ask "what attributes will be searched for or written to most frequently?" !!!
This will optimize searching in the database. This would be interesting to test this with/without index.


When using "os.environ.get() or something", this should make the code less fragile and makes
it more flexible for deployment. All that needs to be done is to set an environment variable in production.

    DB MIGRATIONS:----------------------------------------------------
        initialize migration framework: flask db init
            -creates a migrations directory, among other details

        perform a migration: flask db migrate -m "description"
            -generates the python code/script in a file under migrations/
            comment: some of this code seems familiar and similar to Entity Framework,
            upgrade, downgrade, etc.

        apply migration to db: flask db upgrade
            -this will apply the migration to the actual database.
            this should generate the db file in SQLite.

        undo previous migration: flask db downgrade
            -attempts to undo a previous migration.

        db history: flask db history
            -similar to git hist or log

        current db migration: flask db current
            -similar to git status
            -works only if you have applied a migration already



    CRUD operations -------------------------------------------

    CREATE  db.sesssion.add(element)
    READ    [ModelName].query.get(id) or [ModelName].query.all() or [ModelName].query.order_by()
    UPDATE  just modify the object in place and call db.session.commit() to save
    DELETE  db.session.delete(element)

    TRANSACTIONS
    COMMIT changes - db.session.commit()


SESSION / LOGIN----------------------------------------------------------


    Dependencies:
            flask-login (Session Management dependency)
            pipenv install flask-login

    DEFINITION: A user "session" is a private storage that is allocated for each client that connects to the application

    initialization: from flask_login import
                    object: LoginManager -> register tha app with the extension,
                    class: UserMixin -> enables a User model to become compatible with flask-login,
                    static function: login_user -> updates current_user,
                    object: current_user -> represents A) the logged in user or
                                                       B) an anonymous user if they aren't logged in.
    login = LoginManager(app)

    flask-login can work with any User model class. Requires 3 attributes and 1 method to be implemented.
        1) extend your User model from UserMixin -> class User(UserMixin, otherparams)
        2) @login.user_loader function loads the user id into a session. placed in User model as static method.
        3) login_user(user_object)

    ***IMPORTANT*** flask-login treats id's as strings. Must convert to int if you're intending to use it as an int.

    Workflow for Login
                prerequisites - import login_user from flask-login.
                                  - some User model has been created.
                                  - User class must extend/inherit UserMixin.
                                  - import werkzeug.security: generate_password_hash, check_password_hash methods
                                  - implement some set/get password_hash method in your User model

                steps - 1) extend the @login.user_loader function with a function that returns the User's int(id)
                        2) test that the username exists in the database, if so grab the user returned.
                            -use filter_by().first() to check if the username exists
                        3) check hash of the form password against password_hash stored in database.
                        4) redirect user back to login w/ ambiguous flash message if they fail authentication.
                        5) if step 3 suceeds, use login_user(user, remember=true/false) from flask-login to start a new session

    Helpful features:

        set login.login_view to the method that calls the login form page: login.login_view = 'login'
        This will auto-redirect users to the login page when the rule is added *underneath* the @app.route decorators.
        url_for() is used underneath this feature to call the correct action.

        @app.route("/")
        @app.route("/some/route")
        @login_required
        def func():
            pass

        After implementing login_required, it is good practice to redirect the user the page which they originally
        intended to visit in the first place.
        To help with this, flask-login will add URL query string "?next=%2Findex" meaning "next=[originally requested url]"
        After the login is successful, you may redirect the user the to the page they wanted using this query string.
        BUT before you redirect, SECURITY make sure that the URL is only redirecting to our site and not someone else's, in case of
        attack use werkzeug.urls : url_parse()


PASSWORD HASHING: --------------------------------------------------------
use werkzeug.security package methods: 1) generate_password_hash("phrase"), 2) check_password_hash(hash, "phrase")
Every time generate_password_hash() is called, even with the same parameters, a brand-new hash is generated!!!


REGISTRATION: -------------------------------------------------------

    Heavily relies upon flask-wtf validators. Two methods can be added to the registration form class to instruct
    flask-wtf to validate unique fields within the database as part of validation protocol for that form.

    class RegistrationForm(FlaskForm):
        [form code]

        def validate_[attribute](self, attrib):
            exists = [Model].query.filter_by(attrib=attrib).first()
            if exists is not None:
                raise ValidationError("error validating attrib")

    After this, we do not have to take care of anymore validation in our route. We let flask-wtf do this for us. That
    way we can concentrate on the registration process at a more high level.


DATABASES REVISITED: -------------------------------------------------

RELATIONSHIPS: ----

Cheat sheet: needs verified

if direction1 == 1 to many and direction2 == 1 to many:
	return many-to-many

	example:    direction1 = 1 project managed by many employees => 1 to many
	            direction2 = 1 employee manages many projects    => 1 to many
	            result many to many

if direction1 == 1 to many and direction2 == 1 to 1:
	return one-to-many

	example:    direction1 = 1 user has many posts => 1 to many
	            direction2 = 1 post has 1 user     => 1 to 1
	            result = 1 to many

if direction1 == 1 to 1 and direction2 == 1 to 1:
	return 1 to 1

	example:    direction1 = 1 person can be 1 superhero => 1 to 1
	            direction2 = 1 superhero can be 1 person => 1 to 1
	            result = 1 to 1

    ISSUES: -----
    Once columns have been named, renaming columns in SQLite seems to be unsupported somehow. Postgres and MySQL
    don't seem to have this problem.
     
    Solutions:
        1) Keep migrations versions stored as backups
        2) Reinitialize the database from current code base - what I did

    Why are there no commits outside of the routes functions???
    -The routes functions represent the duration of a request. We only want to commit at the very end of the request.
    If we commit in the middle and then the transaction gets interrupted/terminated the full integrity of the request is
    compromised.  

    RELATIONSHIP REPRESENTATIONS IMPLEMENTED:

    ONE - to - MANY -

    Users to Posts : 1 User has many Post, 1 post belongs to 1 user => 1 to many relationship

    Here, the "many side" is the Post table. To implement the 1 to many relationship, each Post must have a connection
    to exactly 1 user.

    Solution: we place a foreign key inside of Post (many side) that references the primary key of the User (1 side) table.

    MANY - to - MANY -
    Miguel says...
    Many to many relationships cannot be implemented simply by inserting foreign keys. They are implemented using an
    auxiliary table. Recall the example given in CSCI 520.

    Tables: Customers, Bars

    Consider the relationship. One customer can frequent many bars. 1 bar can host many customers.
    This is a many to many situation.

    The implementation is an auxiliary table that I will call "Frequents". Frequents is, at minimum, comprised of
    1 FK that links to each customer + 1 FK that links to each bar + 1 PK (required for any table)

    1 - to - 1

    Implemented as 1 to many, but with a constraint enforced on the many side to be either 0 or 1

UNIT TESTING: -----------------------------------------------------------

    Dependencies: none OR pytest

    Python3 "unittest" library - https://docs.python.org/3/library/unittest.html

    4 Components involved ---

        Test Fixture - (test preparation)

            This is the CONTEXT of the test. Anything to do with the environment that needs to be created is part of
            the test fixture for ***temporary*** testing purposes. For example:
                *starting then stopping a server
                *creating then destroying a database
                *creating then destroying directories or files

            setUp() - setup temporary resources and context
            tearDown() -  remove components of setup()

        Test Case - (individual unit of testing)

            This is the individual unit of testing, which checks for a specified response to inputs. Stored in the
            "unittest" library is the class named TestCase which is used to create test cases.

        Test Suite -

            A test suite at minimum combines many test cases that must be executed together. A test suite can also
            be composed of other test suites.

        Test Runner -

            This orchestrates the test cases and provides the outcome to the user. The end game of the test runner is
            to accumulate test results and display them in a report.


        Inside of a test class, per convention, you must prepend any test method with "test_".

        CORE test methods - assert

        *assertEqual()
        *assertTrue()
        *assertFalse()
        *assertRaises()



FINISHING FUNCTIONALITY in Pagination Chapter ----------------------------------------------------------------------

    Dependencies: none

    Blog Posting

        *Create a new Blog Post
        -Add a form class to handle submission of blog posts
        -render the form in the page you wish to have users submit posts
        -make a route OR apply form to current page route.

        *Displaying blog posts
        -use the _posts.html template to render all kinds of post groupings (ex, for username or time-date)
        -read posts from database
        -use Post model???

        *Adding "explore" mode
        -removes the blog submission form from index when "/explore" is called in a request.
        -create a route & require login

        *Navigating pages of blog posts
        The dbms & SQLAlchemy have pagination features and can therefore keep track of sets of results. We don't want
        100 results per page. That's impractical. So we use the dbms to help manage that information along with SQLAlchemy.
        -Use the pagination object to obtain the next or prev page: posts.next_num OR posts.prev_num. Pagination comes
        with SQLAlchemy
        -after obtaining the next and prev nums for pages, insert them into the query string via url_for('action', query_str=value)

            I kept the pagination links of the post results within the _posts template. It would seem to be good practice
            to keep them together with their functionality. That way anytime I call "include("_posts.html")", the navigation
            functionality will be presented to the user automatically. I don't see a reason why I should not do it this way.



    Note: It is considered bad practice to render a page in response to a post request. Instead, redirect!

        WHY?

            if the user hits 'refresh' in their browser, the post request will be resubmitted an additional time.
            This forces a GET request as opposed to resubmitting POST.

            if this best practice is not followed, then the post will likely create duplicate entry in the database.


EMAIL FUNCTIONALITY: ----------------------------------------------------------------------------

    EMAIL SERVER DEBUGGING with python's built-in SMTP mail server:

        1. export MAIL_PORT=[port number you want your app to use]
        2. export MAIL_SERVER=localhost

        -start the server: python -m smtpd -n -c DebuggingServer localhost:[port number your app is using]


    ASYNCHRONOUS (multi-tasking) EMAIL FUNCTIONALITY:

    Note: I use process and thread interchangeably, which isn't technically correct. This needs some more clarification
    and/or correction. If this note is still here, I have not completed this step.

    Why use an asynchronous process?
        In the case of emails, they take about 2-3 seconds or more to complete the request of sending an email.
        During that time, the application cannot listen to or response to new requests.
        The solution is to allocate a separate CPU core or thread to perform this job. So we hand off the process, so
        that the application can remain open to subsequent or any other requests.

    What I've already learned about processes before this course:
        Processes are managed by the operating system. Processes have permissions assigned by the operating system.
        Processes can start other processes. A parent process can start a child process. That child process inherits all
        of the permissions of its parent by default.

        In java, the "main()" thread is the parent process. When you start another thread from that one, that would be a
        child process of "main()".

        This "should" work similarly in Python also (since it's controlled by the OS and not by the compiler/language.


CSS FRAMEWORKS: ---------------------------------------------------------------------

    Dependencies:

            flask-bootstrap: pipenv install flask-bootstrap

    BOOTSTRAP provides a framework of UI components built with html, css & javascript

    https://getbootstrap.com/

        Workflow with bootstrap -
        1. Look at which component is needed in the example.
        2. adapt it to your needs.


DATES & TIMES: ----------------------------------------------------------------------

    Dependencies:

            flask-moment -> Moment.js

    In the event that the application, it's data, or both needs to physically move time zones, we must not let that
    change affect our historical data.

    1. If we use, python's datetime.now(), it will give us our local time.
    2. If we use, python's datetime.utcnow(), it uses utc time universally.

    Option 2 allows for keeping dates and times consistent if we have to move the application server.

    *BUT ..... what about a users expectations??? They expect times to be displayed LOCALLY. So in order to meet their
    expectations, we must convert back to their local time.

    Converting UTC to Local Time: ----------------------------------------------------

    Solution options:  1. The server computes the time zone of each user remembering their time zone.
                       2. Send the utc time to the client. The client computes utc time to local time.
                            *this option seems much more flexible and much better for maintenance in the future.


    We have selected option 2, which uses Moment.js. Actually we do not use Moment.js directly. Instead, we use
    flask-moment which wraps Moment.js and makes it accessible to Jinja.

    *don't forget to add the JavaScript library to the base template so flask-moment will work.


INTERNATIONAL LANGUAGE SUPPORT: ------------------------------------------------------

    Dependencies:
            flask-babel

    Added a variable to Config called LANGUAGES = [] which holds a list of country language codes to be used in translation.
    Initialized a Babel object and passed in the application instance to it.

    How should we decide which language to serve to the client???
    Solution: The browser can tell us the location and, thus, the language used by that location. It is found in the HTTP
    header.

    Flask has built-in support already for querying the browsers language preference:

        # __init__.py
        @babel.localeselector
        def get_locale():
            return request.accept_languages.best_match(app.config['LANGUAGES'])

    from flask_babel import _

    _() from flask_babel is a method which rearranges the string in a sentence

    the "_" function is used to translate an application's text at "request time" as expected like any typical method.
    Use this function for any string in code that *executes during a request*. This includes flask-form validators.

    the "lazy_gettext" function delays it's decision making of how the text should read until the string
    is called ***after the module*** is parsed and loaded, unlike typical method calls.
    Use this for any string that requires translation apart from requests.

    workflow:

            1) install flask-babel
            2) mark text for translation
            3) extract translations from template into file:
                command: pybabel extract -F babel.cfg -k _l -o messages.pot .

FLASK VARIABLE "g": -------------------------------------------

    g can be used and modified in before_request and subsequently can be used in activity during the request also.
    It is also accessible in all the templates.



AJAX (Asynchronous Javascript And Xml): -----------------------------------------------------

       Translate button AJAX implementation: -----

            User clicks translate button. Before this, the application knows the preferred language of the user. So it
            knows A) the language of the post & B) the language of the user; now it can make a succesfull translate request.

            For step A, if the blog post does not equal the language of the current_user, display the translate button.
            A Javascript function will execute upon click of the translate button. The request response will look like..

            Javascript function sends request to => Our Flask app;
            Flask app makes a request for translation of text => 3rd party service/API;
            3rd party service/API responds to our request .... then what???/

            my guess...

            3rd party service sends response => flask app;
            flask app sends response => the client;
            Javascript function catches this response and renders the translation;
            END

       Packages: pipenv install ...
            guess-language_spirit
            requests

            The below guide is more of a guide to API calls and not specifically about AJAX...

            STEP 1: *** Guess the language of the post. ***
                    This is a pre-requisite for Microblog ONLY. It is one of the parameters required for making
                    a successful request.
                    When a post is submitted, run "guess_language(str)".
                    Once the language is guessed, store the language of the post in the database with the post.

            STEP 2: *** Display the link that makes a request to the function. ***
                    In this case, it is the translate function.
                    The translate link triggers the Javascript to send a request to the "/translate" route,
                    which calls the top level function.

            STEP 3: *** Build the Javascript function ***

            STEP 4: *** Build the route for the functionality ***
                    This is the high level request that calls a subsequent request to a 3rd party API.

            STEP 5: *** Build the request to the 3rd party; Handle the response ***
                    This is the subsequent request referenced in step 3. In general, this relies on HTTP.
                    This request requires a few things:
                        THE REQUEST -
                        A) An Authentication Token
                        B) A known base url
                        C) Parameters to send along with the request
                        Note: All of the above you should be able to find from the documentation of the API provider.

                        THE RESPONSE -
                        D) Check that the response code is 200 - if it isn't return an error message
                        E) Format the data according to response format. Usually there is documentation to support this
                            from the service provider. Or you can also use a REST API client like Insomnia. Or you may
                            be able to use your browser. It's important to note the structure of the response and
                            traverse the data structure as necessary and grab what you need.
            STEP 6) *** Return the response to the client. ***
                    Handle the client side as necessary
            END!

       MS TRANSLATOR SERVICE base URL:
            https://api.microsofttranslator.com/v2/Ajax.svc/Translate?

       Things to remember:

            The $ character is an accessor provided by jQuery in $('#post1').text() code.
            jQuery is one dependency of the bootstrap dependency "flask-bootstrap"




APPLICATION STRUCTURE: ------------------------------------------------------------------

    Previous to this point in the tutorial, the structure (directory structure, separation of concerns) is appropriate
    for small and medium sized applications. But there are two main limitations with the current structure.

    1. We have positioned & grouped code based on high-level function.

        Ex, routes.py contains routes top-level functionality for multiple concerns. The "/translate" route is in
        the same module as "/login". The same module also includes code for resetting passwords.

        If the code base grows beyond this point, it will become mixed and difficult to sort through and maintain.
        Think about trying to debug potentially HUNDREDS of routes. Do you like scrolling down for miles just to find
        one pathetic bug??? NOOOOO!!!!

        One solution is to be able to separate the code into subsystems: login, logout, password reset, translate

    2. Our application instance is at the global level.

        We have do not have much ability to customize the configuration of the application before the instance is created.


    BLUEPRINTING: -----------------------------------------------------------------------

        A blueprint represents a subset of the application: auth (login, logout, password reset), errors, translations.

        For each of the systems, you can create blueprint instance. The blueprint instance has many of the the features
        of the Flask "app" instance, like registering routes.

        Blueprints are INACTIVE. You may use them like an app instance, but they must later be registered with the app
        instance.

        Opinion: I've started to think of Blueprints as a tool to offer some sort of "Inversion of Control".
        See SOLID design principles by Bob Martin.
        https://www.youtube.com/watch?v=TMuno5RZNeE&t=3980s

        Support for opinion:
        Inversion of Control says... we should not allow low level details to control top level instructions.
        This is especially important for large systems that require compiling, like in C based languages.

        APPLICATION FACTORY: ----------------------------------------------

        Enables construction of custom configured application. The "app" instance initialization must be performed in
        an application factory function. It will be called "create_app".

        RESTRUCTURED TESTS: ------------------------------------------

        Restructured tests here. Need to revisit.

        ENVIRONMENT VARIABLES: ------------------------------------------

        Load environment variables automatically in .env file

        REQUIREMENTS FILE: ---------------------

        I don't need this! I'm using pipenv!!! :)

        After restructuring, all of my "url_for" calls in my templates broke. At this point I am glad I made a urls.py
        module to store names of Actions (names of methods that decorated the app.route("") function).

        I decided to pass the action names to all templates via @app.context_processor.
        The problem was that I was using blueprints instead: @bp.context_processor. This is not the proper way.
        You must use @bp.app_context_processor.

        TAKEAWAY:
        All the methods in the flask API that start with "app_*" are meant for use outside of the blueprint.


FULL TEXT SEARCH: --------------------------------------------------------

        Docs: https://elasticsearch-py.readthedocs.io/en/master/api.html

        Scenario:

            What if I wanted to search for certiain words or phrases within all blog posts?

        Relational databases have non-relational extensions that allow for creating full-text index. Their implementations
        are all different, so SQLAlchemy won't help us.

        A few full-text search engines:

        Elasticsearch, Apache Solar, Moosh, and more...

        We are using... Elasticsearch. It is written in Java.

        Python client: pipenv install elasticsearch

        Our blog post data will be written to both SQLite & Elasticsearch. That means if for some reason we must edit
        a post, we must persist the changes in Elasticsearch and the database.

        The versions of Elasticsearch vary greatly in terms of how to query & write text. Be sure to read the docs.
        For instance, doc_type is used in < v5, _doc is used in v6, and it has been deprecated in version 7.

        This affects how the search() method is constructed.

        SQLAlchemy triggered events: --------------------------------------------------


        Workflow:
                    1) build functionality to communicate with Elasticsearch via client.
                        A) write data
                        B) delete data
                        C) query - this returns information that can be used to query the database

                    2) Get the database reference information from the query functionality




