This text file is merely a blob of info I threw onto it when following Miguel Grinberg's Flask Tutorial.
The text is **ROUGHLY** in order. Use this as a reference, not as a novel ;)

D: = Dependency
* D: flask-wtf: library used to create web forms.

To use this extension, the flask instance "app" object must be configured with a secret key.
*SECURITY NOTE: Protects against Cross-Site Request Forgery. CSRF
implemented in the template as a hidden input inside a form: {{ form.hidden_tag() }}

* flash() method
To use this, you must both call the method when the route is called and call "get_flashed_messages()"
in the template. The way I think of this is that it is placed into a buffer which is loaded
onto the next screen.

* validation errors -
Flask-wtf validators that are passed to StringField, PasswordField etc constructors contain an
iterable error list object. Simply call them in the template: form.username.errors, or form.password.errors

* url_for -
url_for allows for generating URLs for specific views and enables less fragile code.
If the code is restructured within the filesystem, url_for() will retrieve the URL dynamically.
Just specify the name of the method that calls the action.

urls are no longer hardcoded into views

DATABASES: -------------------------------------------------

Workflow:
            1) install dependencies: flask-sqlalchemy, flask-migrate
            2) setup database configuration URL in Config class; turn tracking on/off
            3) instantiate SQLAlchemy object in __init__.py, passing app to the instance
            4) instantiate Migrate object in __init__.py, passing db and app to instance
            5) create models:
                create table schema, optimize performance (create an index), define relationships.
                __repr__(self): define this for debugging
                NOTE: after this step is completed, the model only exists as Python objects.
                      These models need to be migrated (generated into a script),
                      then applied to an actual database.
            6) Initialize migration framework: flask db init
            7) create migration scripts - flask db migrate -m "description"
            8) apply/remove migrations to the database - (apply)flask db upgrade OR (remove) flask db downgrade
            

Models:
            *All classes inside of models.py inherit from the SQLAlchemy class called "Model"
                ex, [SQLAlchemy instance].Model or "class MyModel(db.Model)"

* D: flask-sqlalchemy: (Object Relational Mapper)
    - supports SQLite, MySQL, and Postgres.
    - enables an application to switch from any one of these DBMS systems without
        making changes to the application
    - I am using SQLite as a development-only database for this tutorial.
        may also be a good production tool for gvlswing.com admin CMS since it will be small
        scale and simple for now.

* D: flask-migrate: (Database Migration Framework) Alembic migration framework flask extension
    - The migration framework is for development purposes. Because development often requires making
        changes to the database schema, this framework helps to place those changes, which are tedious
        when performed by hand in SQL

DB indexing - how to decide what to index?
Ask "what attributes will be searched for or written to most frequently?" !!!
This will optimize searching in the database. This would be interesting to test this with/without index.


When using "os.environ.get() or something", this should make the code less fragile and makes
it more flexible for deployment. All that needs to be done is to set an environment variable in production.

    DB MIGRATIONS:----------------------------------------------------
        initialize migration framework: flask db init
            -creates a migrations directory, among other details

        perform a migration: flask db migrate -m "description"
            -generates the python code/script in a file under migrations/
            comment: some of this code seems familiar and similar to Entity Framework,
            upgrade, downgrade, etc.

        apply migration to db: flask db upgrade
            -this will apply the migration to the actual database.
            this should generate the db file in SQLite.

        undo previous migration: flask db downgrade
            -attempts to undo a previous migration.

        db history: flask db history
            -similar to git hist or log

        current db migration: flask db current
            -similar to git status
            -works only if you have applied a migration already



    CRUD operations -------------------------------------------

    CREATE  db.sesssion.add(element)
    READ    [ModelName].query.get(id) or [ModelName].query.all() or [ModelName].query.order_by()
    UPDATE  just modify the object in place and call db.session.commit() to save
    DELETE  db.session.delete(element)

    TRANSACTIONS
    COMMIT changes - db.session.commit()


SESSION / LOGIN----------------------------------------------------------

    * PASSWORD HASHING--------------------------------------------------------
    use werkzeug.security package methods: 1) generate_password_hash("phrase"), 2) check_password_hash(hash, "phrase")
    Every time generate_password_hash() is called, even with the same parameters, a brand-new hash is generated!!!


    DEFINITION: A user "session" is a private storage that is allocated for each client that connects to the application

    D: flask-login (Session Management dependency)
    pipenv install flask-login
    initialization: from flask_login import
                    object: LoginManager -> register tha app with the extension,
                    class: UserMixin -> enables a User model to become compatible with flask-login,
                    static function: login_user -> updates current_user,
                    object: current_user -> represents A) the logged in user or
                                                       B) an anonymous user if they aren't logged in.
    login = LoginManager(app)

    flask-login can work with any User model class. Requires 3 attributes and 1 method to be implemented.
        1) extend your User model from UserMixin -> class User(UserMixin, otherparams)
        2) @login.user_loader function loads the user id into a session. placed in User model as static method.
        3) login_user(user_object)

    ***IMPORTANT*** flask-login treats id's as strings. Must convert to int if you're intending to use it as an int.

    Workflow for Login
                prerequisites - import login_user from flask-login.
                                  - some User model has been created.
                                  - User class must extend/inherit UserMixin.
                                  - import werkzeug.security: generate_password_hash, check_password_hash methods
                                  - implement some set/get password_hash method in your User model

                steps - 1) extend the @login.user_loader function with a function that returns the User's int(id)
                        2) test that the username exists in the database, if so grab the user returned.
                            -use filter_by().first() to check if the username exists
                        3) check hash of the form password against password_hash stored in database.
                        4) redirect user back to login w/ ambiguous flash message if they fail authentication.
                        5) if step 3 suceeds, use login_user(user, remember=true/false) from flask-login to start a new session

    Helpful features:

        set login.login_view to the method that calls the login form page: login.login_view = 'login'
        This will auto-redirect users to the login page when the rule is added *underneath* the @app.route decorators.
        url_for() is used underneath this feature to call the correct action.

        @app.route("/")
        @app.route("/some/route")
        @login_required
        def func():
            pass

        After implementing login_required, it is good practice to redirect the user the page which they originally
        intended to visit in the first place.
        To help with this, flask-login will add URL query string "?next=%2Findex" meaning "next=[originally requested url]"
        After the login is successful, you may redirect the user the to the page they wanted using this query string.
        BUT before you redirect, SECURITY make sure that the URL is only redirecting to our site and not someone else's, in case of
        attack use werkzeug.urls : url_parse()


REGISTRATION: -------------------------------------------------------

    Heavily relies upon flask-wtf validators. Two methods can be added to the registration form class to instruct
    flask-wtf to validate unique fields within the database as part of validation protocol for that form.

    class RegistrationForm(FlaskForm):
        [form code]

        def validate_[attribute](self, attrib):
            exists = [Model].query.filter_by(attrib=attrib).first()
            if exists is not None:
                raise ValidationError("error validating attrib")

    After this, we do not have to take care of anymore validation in our route. We let flask-wtf do this for us. That
    way we can concentrate on the registration process at a more high level.


DATABASES REVISITED: -------------------------------------------------

RELATIONSHIPS: ----

Cheat sheet: needs verified

if direction1 == 1 to many and direction2 == 1 to many:
	return many-to-many

	example:    direction1 = 1 project managed by many employees => 1 to many
	            direction2 = 1 employee manages many projects    => 1 to many
	            result many to many

if direction1 == 1 to many and direction2 == 1 to 1:
	return one-to-many

	example:    direction1 = 1 user has many posts => 1 to many
	            direction2 = 1 post has 1 user     => 1 to 1
	            result = 1 to many

if direction1 == 1 to 1 and direction2 == 1 to 1:
	return 1 to 1

	example:    direction1 = 1 person can be 1 superhero => 1 to 1
	            direction2 = 1 superhero can be 1 person => 1 to 1
	            result = 1 to 1

    ISSUES: -----
    Once columns have been named, renaming columns in SQLite seems to be unsupported somehow. Postgres and MySQL
    don't seem to have this problem.
     
    Solutions:
        1) Keep migrations versions stored as backups
        2) Reinitialize the database from current code base - what I did

    Why are there no commits outside of the routes functions???
    -The routes functions represent the duration of a request. We only want to commit at the very end of the request.
    If we commit in the middle and then the transaction gets interrupted/terminated the full integrity of the request is
    compromised.  

    RELATIONSHIP REPRESENTATIONS IMPLEMENTED:

    ONE - to - MANY -

    Users to Posts : 1 User has many Post, 1 post belongs to 1 user => 1 to many relationship

    Here, the "many side" is the Post table. To implement the 1 to many relationship, each Post must have a connection
    to exactly 1 user.

    Solution: we place a foreign key inside of Post (many side) that references the primary key of the User (1 side) table.

    MANY - to - MANY -
    Miguel says...
    Many to many relationships cannot be implemented simply by inserting foreign keys. They are implemented using an
    auxiliary table. Recall the example given in CSCI 520.

    Tables: Customers, Bars

    Consider the relationship. One customer can frequent many bars. 1 bar can host many customers.
    This is a many to many situation.

    The implementation is an auxiliary table that I will call "Frequents". Frequents is, at minimum, comprised of
    1 FK that links to each customer + 1 FK that links to each bar + 1 PK (required for any table)

    1 - to - 1

    Implemented as 1 to many, but with a constraint enforced on the many side to be either 0 or 1

UNIT TESTING: -----------------------------------------------------------

    Python3 "unittest" library - https://docs.python.org/3/library/unittest.html

    4 Components involved ---

        Test Fixture - (test preparation)

            This is the CONTEXT of the test. Anything to do with the environment that needs to be created is part of
            the test fixture for ***temporary*** testing purposes. For example:
                *starting then stopping a server
                *creating then destroying a database
                *creating then destroying directories or files

            setUp() - setup temporary resources and context
            tearDown() -  remove components of setup()

        Test Case - (individual unit of testing)

            This is the individual unit of testing, which checks for a specified response to inputs. Stored in the
            "unittest" library is the class named TestCase which is used to create test cases.

        Test Suite -

            A test suite at minimum combines many test cases that must be executed together. A test suite can also
            be composed of other test suites.

        Test Runner -

            This orchestrates the test cases and provides the outcome to the user. The end game of the test runner is
            to accumulate test results and display them in a report.


        Inside of a test class, per convention, you must prepend any test method with "test_".

        CORE test methods - assert

        *assertEqual()
        *assertTrue()
        *assertFalse()
        *assertRaises()



FINISHING FUNCTIONALITY in Pagination Chapter ----------------------------------------------------------------------

    Blog Posting

        *Create a new Blog Post
        -Add a form class to handle submission of blog posts
        -render the form in the page you wish to have users submit posts
        -make a route OR apply form to current page route.

        *Displaying blog posts
        -use the _posts.html template to render all kinds of post groupings (ex, for username or time-date)
        -read posts from database
        -use Post model???

        *Adding "explore" mode
        -removes the blog submission form from index when "/explore" is called in a request.
        -create a route & require login

    Note: It is considered bad practice to render a page in response to a post request. Instead, redirect!

        WHY?

            if the user hits 'refresh' in their browser, the post request will be resubmitted an additional time.
            This forces a GET request as opposed to resubmitting POST.

            if this best practice is not followed, then the post will likely create duplicate entry in the database.
